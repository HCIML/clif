#ifndef _CLIF_ENUMTYPES_H
#define _CLIF_ENUMTYPES_H

#include <unordered_map>
#include <typeindex>
#include <string.h>
#include <cstdint>
#include <vector>

#include <H5Cpp.h>

#include "cliini.h"

namespace clif {
/*
 * \cond invalid type for BaseType lookup
 */
struct InvalidBaseType {};
/*
 * \endcond
 */
  
//base type for elements
enum class BaseType : int {
  INVALID = 0,
  UINT8   = 1,
  UINT16  = 2,
  INT     = 3,
  FLOAT   = 4,
  DOUBLE  = 5,
  STRING  = 6,
//now for complex types - flags in addition to regular type!
  VECTOR  = 8
  };
//WARNING: change BaseTypeAtomicMask in enumtypes.cpp if enum value changes

//constexpr not working in MSVC2013 - reimplement at a later point
inline BaseType operator|(BaseType a, BaseType b)
{
  return (BaseType)((int)a | (int)b);
}

inline BaseType operator&(BaseType a, BaseType b)
{
  return (BaseType)((int)a & (int)b);
}

std::type_index BaseType2typeid(BaseType &type);

#define CLIFALLATOMIC_T_B(CODE) \
CODE(char, BaseType::STRING) \
CODE(uint8_t, BaseType::UINT8) \
CODE(uint16_t, BaseType::UINT16) \
CODE(int, BaseType::INT) \
CODE(float, BaseType::FLOAT) \
CODE(double, BaseType::DOUBLE)

//sadly this does not due to missing constexpr with MSVC2013
//#define VECCODE(T, B) CODE(std::vector<T>, B | BaseType::VECTOR)
#define VECCODE(T, B) CODE(std::vector<T>, BaseType(int(B) | int(BaseType::VECTOR)))
#define CLIFALLVECTOR_T_B(CODE) CLIFALLATOMIC_T_B(VECCODE)

#define CLIFALL_T_B(CODE) CLIFALLATOMIC_T_B(CODE) CLIFALLVECTOR_T_B(CODE)

#define CODE(TYPE ,BASE) {std::type_index(typeid(TYPE)) COMMA (BASE)} COMMA
#define COMMA ,

static std::unordered_map<std::type_index, BaseType> BaseTypeMap = {
  CLIFALL_T_B(CODE)
};
#undef COMMA
#undef CODE
  
template<typename T> BaseType toBaseType()
{
  return BaseTypeMap[std::type_index(typeid(T))];
}

//disable warnungs about bitwise enum combinations not being in enum
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wswitch"

//deep dark black c++ magic :-D
#define CODE(TYPE, BASE) case (BASE) : F<TYPE>()(args...); break;
#define COMMA ,
template<template<typename> class F, typename ... ArgTypes> void callByBaseType(BaseType type, ArgTypes ... args)
{
  switch (type) {
    CLIFALL_T_B(CODE)
    default:
      abort();
  }
}
#undef COMMA
#undef CODE


//deep dark black c++ magic :-D
#define CODE(TYPE, BASE) case (BASE) :  F<ExtraType COMMA TYPE>()(args...); break;
#define COMMA ,
template<typename ExtraType, template<typename,typename> class F, typename ... ArgTypes> void callByBaseType(BaseType type, ArgTypes ... args)
{
  switch (type) {
    CLIFALL_T_B(CODE)
    default:
      abort();
  }
}
#undef COMMA
#undef CODE

#define CODE(TYPE, BASE) case (BASE) : return F<TYPE>()(args...); break;
#define COMMA ,
template<template<typename> class F, typename R, typename ... ArgTypes> R callByBaseType(BaseType type, ArgTypes ... args)
{
  switch (type) {
    CLIFALL_T_B(CODE)
    default:
      abort();
  }
}
#undef COMMA
#undef CODE

#define CODE(TYPE, BASE) case (BASE) : return F<ExtraType COMMA TYPE>()(args...); break;
#define COMMA ,
template<typename ExtraType, template<typename,typename> class F, typename R, typename ... ArgTypes> R callByBaseType(BaseType type, ArgTypes ... args)
{
  switch (type) {
    CLIFALL_T_B(CODE)
    default:
      abort();
  }
}
#undef COMMA
#undef CODE

#pragma GCC diagnostic pop

BaseType toAtomicBaseType(BaseType &type);

  //enum class DataType : int {${DataTypeEnums}};
  enum class DataOrg : int {${DataOrgEnums}};
  enum class DataOrder : int {${DataOrderEnums}};
  enum class ExtrType : int {${ExtrTypeEnums}};
  enum class CalibPattern : int {${CalibPatternEnums}};
  enum class DistModel : int {${DistModelEnums}};
  
  const static char *BaseTypeStr[] = {"INVALID","UINT8","UINT16","INT","FLOAT","DOUBLE","STRING",NULL};
  const static char *DataOrgStr[] = {${DataOrgStrs}};
  const static char *DataOrderStr[] = {${DataOrderStrs}};
  const static char *ExtrTypeStr[] = {${ExtrTypeStrs}};
  const static char *CalibPatternStr[] = {${CalibPatternStrs}};
  const static char *DistModelStr[] = {${DistModelStrs}};
  
  static std::unordered_map<std::type_index, const char **> enum_mappings = { 
    {std::type_index(typeid(BaseType)), BaseTypeStr},
    {std::type_index(typeid(DataOrg)), DataOrgStr},
    {std::type_index(typeid(DataOrder)), DataOrderStr},
    {std::type_index(typeid(ExtrType)), ExtrTypeStr},
    {std::type_index(typeid(CalibPattern)), CalibPatternStr},
    {std::type_index(typeid(DistModel)), DistModelStr}
  };
  
  template<typename T> const char *enum_to_string(T val)
  {
    const char **strs = enum_mappings[std::type_index(typeid(T))];
    
    return strs[int(val)];
  }
  
  template<typename T> T string_to_enum(const char *str)
  {
    const char **strs = enum_mappings[std::type_index(typeid(T))];
        
    if (!strs)
      throw std::invalid_argument("unknown Enum Type for template!");
      
    for(int i=0;strs[i];i++)
      if (!strcmp(strs[i], str)) {
        return T(i);
        }

    return T(-1);
  }
  
BaseType CvDepth2BaseType(int cv_type);
int BaseType2CvDepth(BaseType t);

//FIXME single strings only atm!
int basetype_size(BaseType type);

BaseType cliini_type_to_BaseType(int type);

H5::DataType toH5DataType(BaseType type);
H5::DataType toH5NativeDataType(BaseType type);

//BaseType toBaseType(H5::PredType type);
BaseType toBaseType(hid_t type);

//H5::DataType BaseType_to_PredType(BaseType type);
}

#define ClifEnumString(Type,Var) Type ## Str[ static_cast<int>(Var) ]

#endif