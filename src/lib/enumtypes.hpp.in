#ifndef _CLIF_ENUMTYPES_H
#define _CLIF_ENUMTYPES_H

#include <unordered_map>
#include <typeindex>
#include <string.h>

namespace clif {
  enum class DataType : int {${DataTypeEnums}};
  enum class DataOrg : int {${DataOrgEnums}};
  enum class DataOrder : int {${DataOrderEnums}};
  enum class ExtrType : int {${ExtrTypeEnums}};
  
  const static char *DataTypeStr[] = {${DataTypeStrs}};
  const static char *DataOrgStr[] = {${DataOrgStrs}};
  const static char *DataOrderStr[] = {${DataOrderStrs}};
  const static char *ExtrTypeStr[] = {${ExtrTypeStrs}};
  
  static std::unordered_map<std::type_index, const char **> enum_mappings = { 
    {std::type_index(typeid(DataType)), DataTypeStr},
    {std::type_index(typeid(DataOrg)), DataOrgStr},
    {std::type_index(typeid(DataOrder)), DataOrderStr},
    {std::type_index(typeid(ExtrType)), ExtrTypeStr}
  };
  
  template<typename T> const char *enum_to_string(T val)
  {
    const char **strs = enum_mappings[std::type_index(typeid(T))];
    
    return strs[int(val)];
  }
  
  template<typename T> T string_to_enum(const char *str)
  {
    const char **strs = enum_mappings[std::type_index(typeid(T))];
        
    if (!strs)
      throw std::invalid_argument("unknown Enum Type for template!");
      
    for(int i=0;strs[i];i++)
      if (!strcmp(strs[i], str))
        return T(i);

    return T(-1);
  }
  
}

#define ClifEnumString(Type,Var) Type ## Str[ static_cast<int>(Var) ]

#endif